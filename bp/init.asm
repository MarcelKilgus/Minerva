* Initialises bp entry points
        xdef    bp_init,bp_init0

*        xref    bv_chntx,bv_chnlx
        xref    ca_frvar
        xref    pa_chnam,pa_chnlt,pa_table
* Lots of other "xref"'s generated by pfadd macro

        include 'dev7_m_inc_bv'
        include 'dev7_m_inc_err'
        include 'dev7_m_inc_nt'

        section bp_init

bp_init0
        lea    bptab(pc),a1       point to start of data
;*        bsr.s  bp_init
;*        lea    newtab(pc),a1
* Drop thru to ...

* The vectored utility bp_init

* d0 -  o- error code
* a1 -i  - bp input table
* a6 -ip - base register
* Documentation suggests that d2 was not preserved before... it is now.

reglist reg     d1-d5/a0/a2-a3  bulk of registers we need saved
bp_init
        movem.l reglist,-(sp)
        moveq   #t.mcp,d4
ini
* As we beleive we extend tables properly, lets see if we can do without:
*        moveq   #0,d5           clear msw
        move.w  (a1)+,d5        read number of mc procedures or functions
*        lsl.l   #3,d5           multiply by 8 to get space nec in tables
*        move.l  d5,d1
*        jsr     bv_chntx(pc)    estimated room needed in name table
*        move.l  d5,d1
*        jsr     bv_chnlx(pc)    estimated room needed in name list
* Note: MCS ROM (etc?) underestimates, so chnam may further extend!
readbp
        move.l  a1,a2           set base address
        move.w  (a1)+,d0        offset to the proc/fn
        beq.s   end_0           end of this table?
        add.w   d0,a2
        moveq   #0,d5
        move.b  (a1),d5         read number of chars in name
        move.w  d5,d1
        move.l  bv_bfbas(a6),a0 name must be relative to a6 for chnam
        addq.l  #1,a0           want this past length byte
        move.l  a0,a3           set ready for chnam
copy_ch
        move.w  (a1)+,-1(a6,a0.l) move words - quicker and saves rounding
        addq.l  #2,a0
        subq.w  #2,d1
        bcc.s   copy_ch         2 bytes or more need looping
        add.w   d1,a0
        sf      0(a6,a0.l)      make sure it ends with junk
        movem.l d6/a1-a2,-(sp)  save where we are (d6 destroyed by chnam)
        move.l  a3,a0           back to start of name
        jsr     pa_chnlt(pc)    ensure name is moderately sensible
        bra.s   zapit           ret+0: bad name (zero length!)
                ;               ret+2: ok, a0 moved to end
        sub.w   d5,a0           hopefully move back to start of name
        cmp.l   a3,a0           had we moved on to the end of the name?
        bne.s   zapit           no, we had something invalid about the name
        move.l  pa_table(pc),a2 ptr to keywords (not allowed as names)
        jsr     pa_chnam(pc)    check (create) name
zapit
        moveq   #err.bn,d5      ret+0: bad name (a keyword... or malformed)
                ;               ret+2: ok, d5=index, a2=nt
        movem.l (sp)+,d6/a1/a3  restore where we are
        move.l  d5,d0           either nt index (msw 0) or err.bn
        bmi.s   fin             if we had a bad name, get out now
        jsr     ca_frvar(pc)    in case we are replacing an existing variable
        move.b  d4,0(a6,a2.l)   set mc proc/fn usage
        clr.b   1(a6,a2.l)      clear type (pander to QREF ... lwr)
        move.l  a3,4(a6,a2.l)   put address of proc
        bra.s   readbp          and do the next proc line

end_0
        move.l  d4,d0
        moveq   #t.mcf,d4
        sub.l   d4,d0           have we just done the procedures?
        bne.s   ini             yes, go back for functions.
fin
        movem.l (sp)+,reglist
        rts

* Build basic procedure/function tables
* Although we go to the trouble of calculating the "correct" estimate for the
* first word of each table, we no longer care what it is.

pfhead  macro   head
pfhead  setstr  [head]
pfnl    setnum  7
pfnt    setnum  0
pflab   setstr  pft_[.l]
pfunln  setstr  _
[.lab]  dc.w    [pflab]
        endm

pfadd   macro
ind     setnum  0
loop    maclab
ind     setnum  [ind]+1
        ifnum   [ind] > [.nparms] goto done
txt     setstr  [.parm([ind])]
ref     setnum  [.instr(txt,pfunln)]
ref     setstr  [pfhead][.left(txt,[ref]-1)][.right(txt,[.len(txt)]-[ref])]
        ifnum   [.len(ref)] < 8 goto lenok
ref     setstr  [.left(ref,7)][.right(ref,1)]
lenok   maclab
        ifstr   [.right(ref,1)] <> $ goto useit
ref     setstr  [.left(ref,[.len(ref)]-1)]s
useit   maclab
        xref    [ref]
        dc.w    [ref]-*
        dc.b    [.len(txt)],'[.ucase(txt)]'
pfnl    setnum  [pfnl]+[.len(txt)]+1
pfnt    setnum  [pfnt]+8
        goto    loop
done    maclab
        endm

pftail  macro
        dc.w    0
        ifnum   [pfnl] < [pfnt] goto defit
pfnt    setnum  [pfnl]
defit   maclab
[pflab] equ     [pfnt]>>3
        endm

bptab pfhead bp_
 pfadd print run stop input window border ink strip paper block pan scroll
 pfadd csize flash under over cursor at scale point line ellipse circle arc
 pfadd point_r turn turnto penup pendown move list open close format copy
 pfadd copy_n delete dir exec exec_w lbytes sexec sbytes save merge mrun load
 pfadd lrun new clear open_in open_new cls call recol randomise pause poke
 pfadd poke_w poke_l baud beep continue retry read net mode renum dline sdate
 pfadd adate line_r ellipse_r circle_r arc_r auto edit fill width report tra
 pftail
 pfhead bf_
 pfadd acos acot asin atan cos cot exp ln log10 sin sqrt tan deg rad rnd int
 pfadd abs pi peek peek_w peek_l respr eof inkey$ chr$ code keyrow beeping len
 pfadd dimn day$ date date$ fill$ ver$ err_nc err_nj err_om err_or err_bo
 pfadd err_no err_nf err_ex err_iu err_ef err_df err_bn err_te err_ff err_bp
 pfadd err_fe err_xp err_ov err_ni err_ro err_bl ernum erlin
 pftail

;*Note: A new table such as that below should be added just above this line.
;*newtab pfhead proc_prefix
;* pfadd newproc_name ...
;* pftail
;* pfhead fn_prefix
;* pfadd newfn_name ...
;* pftail

        end
