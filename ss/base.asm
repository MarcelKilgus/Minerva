* Set up interrupt and utility vectors and provide absolute bits
        xref    ss_init,ss_intrd + many more generated by macros

        include 'dev7_m_inc_sv'
        include 'dev7_m_inc_trapv'
        include 'dev7_m_inc_assert'

* k.xxxxxx are constants
* l.xxxxxx are local labels
* t.xxxxxx are vector table exceptions
* others are externals
vec macro
i setnum 0
loop maclab
i setnum [i]+1
o setstr [.parm([i])]
 ifstr [.right(.left(o,2),1)] = . goto x[.left(o,1)]
        xref.[.lab] [o]
 goto xk
xt maclab
o setstr [.right(o,[.len(o)]-2)]>>1+tab
xl maclab
o setstr [o]-ss_base
 goto xk
xk maclab
        dc.[.ext] [o]
 ifnum [i] < [.nparms] goto loop
 endm

repeat macro n op arg
[.lab]
loop maclab
        [op]    [arg]
n setnum [n]-1
 ifnum [n] > 0 goto loop
 endm

        section ss_base

ss_base ; this is (and must be) really zero

*******************************************************************************
* Exception vectors - longwords

* We will cause an illegal instruction exception to occur, and stay occuring,
* should location 0 or 2 be jumped to.
* We use $4c02, an instruction that is illegal based on its first word, and
* one which at least makes the ssp point to ram.
* Note we don't use "a" or "f" line instructions, as people may be using them!
* Also note that extending this to setting the top byte of the initial pc has
* been tried, but found to be somewhat awkward, as the ms byte of the pc has
* to be cleared at some point. A good solution would probably be to route the
* vector to "ipc jmp ss_ramt" in here, where we don't mind absolute jumps.

k.issp  equ     $4c024c02       initial ssp - no longer used as such

l vec.l k.issp ss_ramt  ; 00  0 initial SSP     08  2 initial PC
l vec.l l.berr t.aerr   ; 08  2 bus error       0c  3 address error
l vec.l t.ill  t.div0   ; 10  4 illegal instrn  14  5 divide by zero
l vec.l t.chk  t.trapv  ; 18  6 CHK instruction 1c  7 TRAPV instruction
l vec.l l.q020 t.trace  ; 20  8 priv violation  24  9 trace
l vec.l t.ill  t.ill    ; 28 10 opcode 1010     2c 11 opcode 1010 emulation

*******************************************************************************
* code for trap #0 calls
        dcb.b   ss_base+$5e-4-*,-1
l.trap0
        bset    #5,(sp)         set s bit to stay in supervisor mode
l.rte1
        rte     ; expected just here by painter!

*******************************************************************************
* exception vectors continued

* autovectors:
l vec.l l.rte1 l.rte1                   ; spurious interrupt & level 1
l vec.l ss_int2                         ; level 2
l vec.l l.rte1 l.rte1 l.rte1 l.rte1     ; level 3-6
l vec.l t.int7                          ; level 7

* trap calls:
l vec.l l.trap0  mt_trap  io_trap2 io_trap3     ; 0-3
l vec.l io_trap4 t.trap5  t.trap6  t.trap7      ; 4-7
l vec.l t.trap8  t.trap9  t.trap10 t.trap11     ; 8-11
l vec.l t.trap12 t.trap13 t.trap14 t.trap15     ; 12-15

*******************************************************************************
* utility vectors - words

k.0     equ     0
k.m1    equ     -1

s vec.w mm_alchp mm_rechp ut_windw ut_con   ;  $c0 -  $c6
s vec.w ut_scr   ut_err0  ut_err   ut_mint  ;  $c8 -  $ce
s vec.w ut_mtext ut_link  ut_unlnk k.0      ;  $d0 -  $d6
s vec.w mm_alloc mm_lnkfr io_qset  io_qtest ;  $d8 -  $de
s vec.w io_qin   io_qout  io_qeof  ut_cstr  ;  $e0 -  $e6
s vec.w io_serq  io_serio cn_date  cn_day   ;  $e8 -  $ee
s vec.w cn_ftod  cn_itod  cn_itobb cn_itobw ;  $f0 -  $f6
s vec.w cn_itobl cn_itohb cn_itohw cn_itohl ;  $f8 -  $fe
s vec.w cn_dtof  cn_dtoi  cn_btoib cn_btoiw ; $100 - $106
s vec.w cn_btoil cn_htoib cn_htoiw cn_htoil ; $108 - $10e
s vec.w bp_init  ca_gtint ca_gtfp  ca_gtstr ; $110 - $116
s vec.w ca_gtlin bv_chrix ri_exec  ri_execb ; $118 - $11e
s vec.w bp_let   io_name  md$read  md$write ; $120 - $126
s vec.w md$verin md$sectr pa$graph pa$table ; $128 - $12e
s vec.w pa$expr  pa$strip pa$mist  pf$nwlin ; $130 - $136
s vec.w pf$liste pa$ini   ut$istr  ib$new   ; $138 - $13e
s vec.w bp$chan  bp$chand bp$chnid bp$chnew ; $140 - $146
s vec.w bp$fname ca$cnvrt ca$opexe ca$eval  ; $148 - $14e
s vec.w ip$kbrd  ip$kbend sb$start k.m1     ; $150 - $156
s vec.w mm$move  mm$mrtoa mm$mator mm$mrtor ; $158 - $15e
s vec.w ss$wser  ss$rser  md$selec md$desel ; $160 - $166
s vec.w mm$clear mm$clrr  io$qsetl k.m1     ; $168 - $16e
s vec.w ii$raw   ii$drive k.m1     k.m1     ; $170 - $176

*******************************************************************************
* The tk2 res_128 command expects find itself neatly in the ram_test code by
* setting up a4 and jumping in here.

        dcb.b   ss_base+$184-*,-1
        move.l  a4,d1           enter the reset with a4 set to max mem

*******************************************************************************
* We will now use $186 (390 decimal) for software reset. Just the value of d1.l
* is required. See ss_ramt for the details on this value.

        trap    #0              force ourselves into supervisor mode
        or.w    #$700,sr        block interrupts
        move.l  $5c,a5          put a magic number in a5 (odd value best)
        reset                   press the button!
* the genuine "reset" instruction does nothing, but ...
        movem.l 0,a0-a1         ... proper reset on miracle 68020 board ...
        jmp     (a1)            ... so we made refs to 0-7 for winnie

*******************************************************************************
* Waste a bit more space to get to location for multirom entry point.

        dcb.b   ss_base+$1ac-*,-1
        moveq   #8,d5           mode 8 reset
        jmp     ss_init(pc)     skip ramtest and into init

*******************************************************************************
* Trap redirection code
rd
        move.l  a6,-(sp)        save an address register
        move.l  a7,a6           copy the system stack pointer
        exg     a6,d7           need it in a data register for and
        and.w   #$8000,d7       this is sv_base
        exg     a6,d7           now back in the address register
        tst.l   sv_trapv(a6)    is there a redirection vector?
        bne.s   do_rd           yes - go do it
        move.l  (sp)+,a6        recover register
        sub.l   #tab+aerr>>1+2-ss_base,(sp)+ remove return address
        bne.s   spurint         good - it was not address error
l.berr
        addq.l  #8,sp           for bus or address errors remove junk
spurint
        jmp     ss_intrd(pc)    let it behave as a surious interrupt
* will luck, the above might un-"treacle" the machine...

tab     repeat  rdend/4 bsr.s   rd

do_rd
        move.l  sv_trapv(a6),a6 get the vector table address
        sub.w   #2*(tab+2-ss_base)-sv_trapo,a6 - we've moved the bsr's, sigh!
        add.w   6(sp),a6        add return address ...
        add.w   6(sp),a6        ... twice
        move.l  (a6),4(sp)      put redirected trap address on stack
        move.l  (sp)+,a6        restore the working register
        rts                     branch to the required code

* This code is to sort out the fact that move's from sr are priviledged
* instructions on the 68020, etc.

* The technique employed here is fairly straightforward, if a little slow.

* We check that move sr,daddr is what's being attempted, and if not, go on with
* the normal exception handling for priviledge violations.

* We then always have a shot at converting the instruction to the 68020's move
* from ccr, which will work if the user is in ram, and will mean we don't ever
* have to come back here!

* Although the instruction may well be in ram, we don't check to see if the
* conversion succeeded, as it's conceivable we may have problems with the data
* cache, which might make it look as if we managed to write into rom!

* We then construct live code on the user stack as follows:

* upc-> move    ccr,daddr       1, 2 or 3 words
*       jmp     return          3 word absolute jump
*       ds.w    0..2            padding. note: move ccr,-(sp) will be ok
* usp->

* Note that we now never show the user any extra bits that might be present in
* the msb of the sr value, as they probably wouldn't know what they meant!

* The only assumptions made in the above system are that the user:
*       1) has at least 12 (+1 if odd!) bytes of stack available in ram.
*       2) doesn't mind us overwriting those bytes.
*       3) doesn't store the value over the live code we put there!

ureg    reg     d7/a5-a6
ulen    equ     3*4

isprivv
        movem.l (sp)+,ureg      restore user's registers
        bra.s   tab+priv>>1     go do a real priviledge violation

l.q020
        movem.l ureg,-(sp)      save user's registers
        move.l  ulen+2(sp),a6   get user's return address
        moveq   #$40,d7         first byte identifying all move sr,daddr
        cmp.b   (a6),d7         check the offending instruction
        bne.s   isprivv         it wasn't a move from sr, it's a real violation
        rol.w   #3,d7           move from ccr ($42xx) just needs bit 9 set
        or.w    (a6),d7         construct new 1st word for instruction
        move.w  d7,(a6)+        store it as a replacement, wary of rom/cache
        move    usp,a5          find user's stack
        exg     a5,d7           being ultra cautious...
        bclr    #0,d7           ... make certain it's at an even address...
        exg     a5,d7           ... so we'll never crash in here!
        sub.w   #2*6,a5         4, 5 or 6 words of live code
        move.l  a5,ulen+2(sp)   replace return address with live code address
        move.w  d7,(a5)+        put 1st, or only, word of new instruction
        cmp.b   #$e8,d7         check instruction size (move sr,daddr >= $40c0)
        bcs.s   srset           modes less than 5 need no more
        move.w  (a6)+,(a5)+     copy first, or only, extra instruction word
        addq.b  #256-$f9,d7     is destination absolute long?
        bcs.s   srset           no, that's ok
        move.w  (a6)+,(a5)+     copy lsw of absolute long address
srset
        move.w  #$4ef9,(a5)+    put in jmp $xxx.l instruction 1st word
        move.l  a6,(a5)         complete with address after their instruction
        movem.l (sp)+,ureg      restore user's registers
        rte                     let 'em have it

        end
