* RAM test at boot up
        xdef    ss_ramt

        xref    ss_init
        xref    tb_hex

        include 'dev7_m_inc_mc'
        include 'dev7_m_inc_pc'
        include 'dev7_m_inc_assert'

ii.raw  equ     $170    use vector to get to i2c code

magic   equ     $5c     where we get a magic, odd longword to check with a5
scr1    equ     $20000  first screen address
scr2    equ     $28000  dual screen address
i_sp    equ     $28480  base value for ssp
m16k    equ     $4000   memory resolution we are prepared to handle
ranpat  equ     8191    prime < 32k/4 is top of mem pattern to use

* This allows for software reset (many flavours) as well as initial power up.

* This routine exits with the top of ram, as a multiple of 16384, in a5.

* The test starts with a short delay (150ms) to allow any external devices to
* settle down...

* The test then checks the size of the expansion ram (if present) and tests
* that ram is ok and contiguous from scr1 upwards.

* The test algorithm is to go once round the whole of memory writing and
* checking all ones and a random pattern generated by copying rom into the ram.
* The current clock seconds determines the start of the random pattern.
* A pair of short (150ms) delays is used to encourage refresh failure.
* the random pattern is rechecked without re-writing to detect addressing and
* refresh problems. A zero check is left to the end of the second time
* round, to complete with memory all zero, except for the logo.

* If the test fails, the failure mode is indicated by writing the pattern that
* was being checked, the value read and the address where the problem occured.
* these longwords are written in big, friendly(sic) hex.

* The power up entry point is ss_ramt, but this is also entered after the
* "reset" instruction is executed (as the hardware is not quite proper!).
* The software reset is acheived by jumping to location 390 with d1.l set as
* the type of reset required.
* A magic number is then put into a5.l prior to causing a reset.
* If the magic number is not present when ss_ramt is reached, a standard
* "press the button" reset is forced.

* The value in d1.l is used to decide what sort of restart is required:

*       bit(s)  value   meaning
*       0       0       do the full memory test
*               1       skip the memory test for a quick reset
*       1       0       scan rom slots
*               1       skip the rom slots, unexpand the m/c
*       2       0       normal establishment of memory size
*               1       take the upper memory limit below as gospel!
*       3       0       monitor mode
*               1       tv mode
*       4       0       wait for f1-f4 selection
*               1       skip the f1-f4 selection
*       5-6     0..3    extend supervisor stack by 0K, 8K, 16K or 24K 
*       7       0       set single screen
*               1       set dual screens
*       8-13    0..63   extra blocks of 64k between last screen and system vars
*       14-31           upper limit on memory (0 = no limit)
* (Note that the top bits of d1 are unlikely to ever make sense as memory!)

* The value in d1.l is passed on to ss_init in d5.l.

* One can use the reset direct from superbasic.
* E.g. to quick reset and have dual screens in tv mode, use "call 390,153".

sls     equ     7       bit shift for screen line
sl      equ     1<<sls  bytes per screen line

        section ss_ramt

* The logo is stored as a word (or rather, two bytes) flagging which bytes are
* changing from the row above. This always has bit 1 set, enabling it to double
* up as the loop count of 14 bytes per row as it is shifted left. 
logo
 dc.b $60,$02,$08,$02
 dc.b $60,$02,$1c,$07
 dc.b $60,$02,$3e,$0f
 dc.b $10,$02,$80
 dc.b $60,$02,$7f,$1f
 dc.b $1f,$fa,$8f,$ff,$f1,$ff,$ff,$ff,$ff,$ff,$ff,$c0
 dc.b $74,$0a,$ff,$bf,$cf,$f3,$e0
 dc.b $14,$02,$c7,$e3
 dc.b $ff,$fa,$01,$f3,$fd,$c0,$00,$00,$00,$00,$00,$00,$00,$00,$00
 dc.b $20,$02,$f9
 dc.b $ff,$fa,$03,$e1,$f1,$e1,$ff,$81,$f8,$7f,$f0,$ff,$18,$07,$f8
 dc.b $07,$ba,$c3,$fc,$ff,$f9,$38,$0f,$fc
 dc.b $f4,$ba,$07,$c0,$e0,$e0,$c7,$fb,$3c,$1f,$fe
 dc.b $3b,$da,$40,$f0,$03,$9e,$f1,$f3,$c0,$1e,$1e
 dc.b $e7,$fa,$0f,$80,$00,$8f,$1e,$7b,$c7,$80,$1c,$1c,$0f
 dc.b $1b,$8a,$70,$07,$0e,$7f,$87,$1f
 dc.b $d5,$fe,$1f,$00,$78,$8e,$3f,$0f,$00,$1e,$3c,$3f,$80
 dc.b $07,$0a,$1e,$0f,$3c,$7f
 dc.b $98,$be,$3e,$38,$0f,$1e,$0e,$38,$7b,$c0
 dc.b $17,$3a,$3c,$3c,$07,$1e,$0f,$78,$f1
 dc.b $88,$96,$7c,$0e,$3c,$79,$e0
 dc.b $1d,$be,$1c,$1e,$38,$8f,$38,$07,$73,$ff,$f0
 dc.b $94,$92,$f8,$1e,$78,$f8,$f3
 dc.b $0b,$96,$1c,$03,$83,$e0,$f1,$e0
 dc.b $97,$be,$f0,$0e,$f0,$00,$00,$00,$03,$e0,$00,$00
 dc.b $88,$02,$70,$00
 dc.b $94,$02,$00,$0f,$e0
 dc.b $04,$02,$00
 dc.b $10,$32,$07,$01,$c0
 dc.b $0f,$fe,$8f,$ff,$ff,$ff,$ff,$ff,$f9,$cf,$ff,$fc
 dc.b $00,$36,$fc,$9f,$fe
 dc.b $ff,$00           terminate with a mask word with a zero lsb
 ds.w 0 allign to word boundary

l_len   equ     14*8 number of pixels per row
l_row   equ     32 number of rows 
l_h     equ     50 allow height to match copyright message window
l_w     equ     (l_h*l_len+l_row/2)/l_row pad width up proportionate to height
l_x     equ     (512+448)/2-l_w
l_y     equ     256-l_h
l_off   equ     (l_x*2+l_w-l_len+8)/(8*2)*2 offset to first byte in line
l_1st   equ     l_y+(l_h-l_row+1)/2 first display line

nextword
        move.l  -(a1),d2        fetch a random longword from rom
        jmp     (a2)            go do appropriate bit

l_loop
        move.b  (a3)+,-1(a0)    if carry was set, we patch in our new byte
l_copy
        move.w  -sl(a0),(a0)+   repeat word from row above
        add.w   d7,d7           check our mask
        bcc.s   l_copy          if carry clear, we have no new byte for here
        bne.s   l_loop          if it's zero, we just overshot, but so what!
do_2nd
        btst    d0,d5           is this a quick reset?
        beq.s   chk_rnd         no, keep checking randoms
        move.l  d0,(a4)+        just wipe memory for quick reset

* Come here on second pass, until we've got past the logo
do_logo
        move.l  a4,d3
        cmp.w   #(l_1st+1)<<sls,d3 at the logo line + 1 yet?
        bcs.s   do_2nd          no, carry on
        assert  7,sls
        add.b   d3,d3           are we at the start of a line
        bne.s   do_2nd          no, continue 2nd pass
        lea     l_off-sl(a4),a0 pointer to left hand edge above
        move.b  (a3)+,d7
        asl.w   #8,d7           pick up the mask word (not on a word bdry!)
        move.b  (a3)+,d7        (note - d7.b=0 also marks end of 2nd pass)
        bne.s   l_copy          all real mask words have bit 1 set
        btst    d0,d5           is this a quick reset?
        bne.l   qfin            yes, just go tidy last few bits
        lea     chk_rnd,a2      change to full 2nd pass
chk_rnd
        cmp.l   (a4),d2         check the random word
        bne.s   bad_rand        if it fails
        move.l  d0,(a4)         write zeroes to ram
        tst.l   (a4)+           check them
        dbne    d6,nextword     loop
        move.l  d0,a0
        bra.s   chk_fail

do_1st
* First time round, write ones, read ones, write random and check
        move.l  d7,(a4)         write ones to ram
        cmp.l   (a4),d7         check them
        bne.s   hangup
        move.l  d2,(a4)         write it to ram
        cmp.l   (a4)+,d2        check it
        dbne    d6,nextword     loop
        move.l  d2,a0
chk_fail
        lea     ranpat*4,a1     ready for next block
        beq.l   nextlump        keep going until a fail
        subq.l  #4,a4           back up to failed location
        move.l  a0,d2           now d2 is test value that failed
bad_rand
        move.l  d2,d7           now d7 is test value that failed

* fail locations: indicate failure by screen writing

hangup
        move.l  (a4),d6         pick up failing longword
        moveq   #8<<3+4,d5      set d5 for full, single tv screen reset & count
        lea     scr1-scr2+128*32+64-8*6(a6),a1 start of first display line
sh_word
        moveq   #7*4,d3         7 lines each repeated 4 times
sh_line
        moveq   #-32/4,d2       hex digits per longword
sh_byte
        lea     tb_hex-$4000+6,a0 base of small hex digits
        rol.l   #4,d7           roll next digit to lsb's
        moveq   #15,d1
        and.b   d7,d1
        moveq   #9*4,d0         (also 6*6)
        mulu    d0,d1
        sub.w   d3,d1
        asr.w   #2,d1
        add.w   d1,a0           pick out row of char
        move.b  $4000(a0),d1
sh_bit
        cmp.b   #6*4,d3
        bcc.s   bltop
        add.b   d1,d1
bltop
        scs     (a1)+
        scs     (a1)+
        subq.b  #6,d0
        bne.s   sh_bit
        addq.w  #1,d2           count down digits (nb saving msw=-1)
        bne.s   sh_byte
        lea     128-2*8*6(a1),a1
        subq.b  #1,d3           count rows
        bne.s   sh_line
        move.l  d6,d7           after bad data, do expected data
        move.l  a4,d6           finally do failing address
        asr.l   #1,d5
        bcc.s   sh_word
        lea     pc_clock+3,a0
        moveq   #15,d0          hang on for 1/4 minute (gold card compat.)
        add.b   (a0),d0
waste
        cmp.b   (a0),d0
        bne.s   waste
        bra.s   retry

* Start of ram test: come here at power on and after "reset" instruction
ss_ramt
        cmp.l   magic,a5        check for magic number in a5
        beq.s   d1set           if it's there, d1 is valid (we hope!)
        moveq   #-1,d7
        dbra    d7,*            waste some time in case of glitch
        lea     iicmd,a3        load command sequence address
        lea     iiret,a0        load return address
        move.w  ii.raw,a5       use vector to get to i2c code
        jmp     $4000(a5)       jump to i2c raw entry point address
iiret
        beq.s   d1set
        moveq   #8,d1           full reset, default tv mode single screen
d1set
        move.l  d1,d5           set d5 for later and passing on to ss_init
        and.w   #-m16k,d1       the top address we're being asked to use
        move.l  d1,a4           upper limit to check ram to
retry
        move.l  #i_sp,sp        ignore original sp and set proper one
        lea     scr2-i_sp(sp),a6 keep a useful address in a6
;        if      ntsc
;        move.b  #64,mc_stat     set 512 pixel mode, 60hz
;        else
        sf      mc_stat         set 512 pixel mode, display screen 0
;        endif
        moveq   #-1,d7          set flag for first time round, and ones test
        move.l  a4,a5           copy upper limit
        btst    #2,d5           is this a forced limit?
        bne.s   res_a5          yes, go use it, whatever it is!
        move.l  a6,a5           start address for checking
        move.w  #m16k,a0        16k increment
        sub.l   a0,a4           pop a bit off limit, so it will compare nice
        bra.s   find_ext

next_add
        move.l  a5,(a5)         set address to self
        move.l  a6,a1           start at bottom
smash
        cmp.l   (a1),a1         check all test words are intact
        bne.s   res_a5          if not, stop here
        cmp.l   a1,a5
        add.l   a0,a1
        bne.s   smash
        add.l   a0,a5           bump up available ram by 16k
find_ext
        cmp.l   a5,a4           are we up to requested/bad memory yet?
        bcc.s   next_add        no, try for more
res_a5
        moveq   #64,d1          (just in case clock bits are zero)
        or.w    pc_clock+2,d1
        lsl.w   #3,d1           2048 possible random starts
        lsr.w   #1,d1
        moveq   #0,d0           permanently zero
        btst    d0,d5           check if quick reset
        bne.s   onepass         if quick, only do 2nd pass
        lea     do_1st,a2       set jump address for first pass
nextpass
        lea     scr1-scr2(a6),a4 beginning of ram to be tested
        move.w  d1,a1           randomised start on entry to pass
nextlump
        add.l   a4,a1           offset by high place in rom for random pattern
        cmp.l   a1,a5           will this go beyond top of ram?
        bcc.s   ranok           no, use full count
        move.l  a5,a1           yes, drop back a bit
ranok
        sub.l   a4,a1           this is top of pattern now
        move.w  a1,d6
        lsr.w   #2,d6           this is the longword counter
        dbra    d6,nextword     if not at end, do next longword
        dbra    d6,*            give refresh 150ms to fall over
        dbra    d6,*            another 150ms at a different memory address
onepass
        lea     do_logo,a2      at begining of second pass, logo checks on
        lea     logo,a3         set pointer to logo
        lsl.w   #8,d7           is this the second pass?
        bne.s   nextpass        no, so go for 2nd pass
gogogo
        move.w  #$3fe0,d0       nine bits we will adjust ssp with
        and.w   d5,d0           pick them out of reset longword
        lsl.l   #8,d0           move them up to their right place
        add.l   d0,sp           set system stack pointer
        jmp     ss_init(pc)     and jump into system initialisation

qfin
        move.l  d0,(a4)+        clean out last bit of screen after logo
        move.w  a4,d3
        bne.s   qfin
        bra.s   gogogo

iicmd
        dc.b    %11001110       trash device, send initialise
        dc.b    $a0/2,%11011110 set device
        dc.b    1,%10100000,20  START/write address byte
        dc.b    4-1,%10110000   START/read d1 four bytes, NAK last
        dc.b    3,%10100100,22,0,8 start/write address, kill lsw boot, STOP
        dc.b    $ff             terminate sequence

        end
